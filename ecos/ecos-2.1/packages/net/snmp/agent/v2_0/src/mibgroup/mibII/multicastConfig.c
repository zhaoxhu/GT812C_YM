
/*
This file is generated by HOST development tools - mib2c, the following gives a basic procedure of adding new mibs.


Following combination of development tools are proven to be working:
  - PERL V5.8.6
  - NET-SNMP V5.2.4
  - LINUX V2.6.11_FC4
  - GCC V4.0.0


How to generate code(.c and .h) for the new mib:
0. Make sure NET-SNMP is installed sucessfully, refer to NET-SNMP document;
1. Enter NET-SNMP source tree, i.e. /opt/net-snmp-5.2.4/local;
2. Put the mib files into this DIR, i.e. UTSTARCOM-ONU204i-SWITCH-MIB.mib UTSTARCOM-ROOT-MIB.mib;
3. Execute the command "export MIBS=ALL";
4. Execute the command "mib2c multicastConfig", then select 1 to generate ucd-snmp style code;
5. Then the multicastConfig.h and multicastConfig.c are generated in this DIR.

Note:
1. multicastConfig must be a valid object-indentifier in the mib file.
2. The code generated has a bug need to be fixed, following will show how to fix this bug.



How to make the code generated by HOST mib2c working with TARGET ECOS NET-SNMP package:
1. Correct the defination of variable_N XXX_variables[];
    N should equal to "MAX level of leaf under XXX" + 1
    For example, for multicaseConfig, the original generated code has a line like
    "struct variable7 multicastConfig_variables[] = {" , Need to change to
    "struct variable4 multicastConfig_variables[] = {" .

2. Put multicastConfig.c to ecos/ecos-2.1/packages/net/snmp/agent/v2_0/src/mibgroup/mibII/
    and put multicastConfig.h to ecos/ecos-2.1/packages/net/snmp/agent/v2_0/include/mibgroup/mibII/

3. Change ecos/ecos-2.1/packages/net/snmp/agent/v2_0/cdl/snmpagent.cdl to compile the new file,
    adding one line for CYGPKG_SNMPAGENT compile option: "mibgroup/mibII/multicastConfig.c"

4. Change NET-SNMP header files to initiate the new mib:
    In "ecos/ecos-2.1/packages/net/snmp/agent/v2_0/include/mib_module_includes.h"
    adding "#include "mibgroup/mibII/multicastConfig.h" at the bottom.

    In ecos/ecos-2.1/packages/net/snmp/agent/v2_0/include/mib_module_inits.h
    adding "init_multicastConfig();" at the bottom.

5. Adding code for GET/SET real data.
    Following the commnets in the code generated by mib2c, and put your memory copy/API calls/... in the lines
    where marked by "VAR = VALUE;"

*/


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

/*
 * minimal include directives
 */
 #include <sys/param.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <net/if.h>
#ifdef CYGPKG_NET_FREEBSD_STACK
#include <net/if_var.h>
#endif
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if_arp.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>

 #include <sys/param.h>
#include "config.h"
#include "mibincl.h"
#include "mibgroup/util_funcs.h"
#include "mibgroup/mibII/multicastConfig.h"
#include "snmp_api.h"


#if 1
// SAL API call begin
#include "iros_common.h"
#include "iros_onu_api.h"
#include "iros_module.h"
#include "iros_log.h"

// user-space data storage
epon_igmp_snooping_config_t igmp_config;
epon_igmp_snooping_config_t igmp_config_old;

epon_uint32_t igmp_timer;
epon_uint32_t igmp_timer_old;

extern epon_uint32_t invoke_id;
extern epon_uint32_t apps_data;

#define DUMP_START_MIB  \
	 diag_printf("start name:       "); 	\						 
        print_mib_oid(name, *length);	\
        diag_printf("vp->name:");	\
        print_mib_oid(vp->name, vp->namelen);	\
        diag_printf("\n");

#define DUMP_END_MIB         \
	 diag_printf(" end name:       ");		\
        print_mib_oid(name, *length);	\
        diag_printf("vp->name:");\
        print_mib_oid(vp->name, vp->namelen);		\
        diag_printf("\n");

/****************************************************************/
/* $rtn_hdr_start  epon_onu_igmp_snooping_get_cb    */
/* CATEGORY   : Device                                          */
/* ACCESS     : public                                          */
/* BLOCK      : General                                         */
/* CHIP       : CS8016                                          */
void epon_onu_igmp_snooping_get_cb(epon_callback_context_t context,
                        epon_result_code_t code,
                        epon_igmp_snooping_config_t *result)
/* INPUTS     : o callback context pointer                      */
/*              o result code defined in iros_common.h          */
/*              o pointer result structure containing the get result */
/* OUTPUTS    : ----                                            */
/* RETURNS    : ----                                            */
/* DESCRIPTION:                                                 */
/* sample callback function for onu igmp snooping get  */
/*                                                              */
/* $rtn_hdr_end                                                 */
/****************************************************************/
{
    int i;

    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "epon_onu_igmp_snooping_get_cb: invoke_id %d apps_data %d code %d\n",
                    context.invoke_id, (int)context.apps_data, code);
    if (code != EPON_RESULT_SUCCESS) {
            return;
    }

    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "enable %d mrouter_learning %d version %d onu_fast_leave %d \n", result->enable,
                    result->mrouter_learning, result->version,result->onu_fast_leave);
    igmp_config_old.enable = result->enable;
    igmp_config_old.onu_fast_leave = result->onu_fast_leave;

    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "static_mrouter_num %d\n", result->static_mrouter_num);
    igmp_config_old.static_mrouter_num = result->static_mrouter_num;

    for (i=0;i<result->static_mrouter_num;i++) {
        IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "  router port 0x%x\n", result->static_mrouter_ports[i]);
        igmp_config_old.static_mrouter_ports[i] = result->static_mrouter_ports[i];
    }
}

/****************************************************************/
/* $rtn_hdr_start  epon_onu_igmp_timer_get_callback    */
/* CATEGORY   : Device                                          */
/* ACCESS     : public                                          */
/* BLOCK      : General                                         */
/* CHIP       : CS8016                                          */
void epon_onu_igmp_timer_get_cb(epon_callback_context_t context,
                        epon_result_code_t code,
                        epon_uint32_t     *result)
/* INPUTS     : o callback context pointer                      */
/*              o result code defined in iros_common.h          */
/*              o pointer result structure containing the get result */
/* OUTPUTS    : ----                                            */
/* RETURNS    : ----                                            */
/* DESCRIPTION:                                                 */
/* sample callback function for onu igmp timer get             */
/*                                                              */
/* $rtn_hdr_end                                                 */
/****************************************************************/
{
    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "epon_onu_igmp_timer_get_cb: invoke_id %d apps_data %d code %d\n",
                    context.invoke_id, (int)context.apps_data, code);

    if (code != EPON_RESULT_SUCCESS) {
            return;
    }
    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "timer: 0x%x\n", *result);
    igmp_timer_old = *result;
}

/****************************************************************/
/* $rtn_hdr_start  sample_onu_igmp_snooping_set_callback     */
/* CATEGORY   : Device                                          */
/* ACCESS     : public                                          */
/* BLOCK      : General                                         */
/* CHIP       : CS8016                                          */
void epon_onu_igmp_snooping_set_common_cb(epon_callback_context_t context,
                        epon_result_code_t code)
/* INPUTS     : o callback context pointer                      */
/*              o result code defined in iros_common.h          */
/* OUTPUTS    : ----                                            */
/* RETURNS    : ----                                            */
/* DESCRIPTION:                                                 */
/* sample callback function for onu igmp snooping set      */
/*                                                              */
/* $rtn_hdr_end                                                 */
/****************************************************************/
{
    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "epon_onu_igmp_snooping_set_common_cb: invoke_id %d apps_data %d code %d\n",
                    context.invoke_id, (int)context.apps_data, code);
}



// SAL API call end

#endif

/*
 * multicastConfig_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             multicastConfig_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 1949, 1, 3, 10, 100, 16, 6, 1 };

/*
 * variable4 multicastConfig_variables:
 *   this variable defines function callbacks and type return information
 *   for the multicastConfig mib section
 */

struct variable4 multicastConfig_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define IGMPSNOOPINGENABLE		1
    {IGMPSNOOPINGENABLE, ASN_INTEGER, RWRITE, var_multicastConfig, 1, {1}},
#define IGMPSNOOPINGAGETIME		2
    {IGMPSNOOPINGAGETIME, ASN_INTEGER, RWRITE, var_multicastConfig, 1, {2}},
#define IGMPSNOOPINGFASTLEAVEENABLE		3
    {IGMPSNOOPINGFASTLEAVEENABLE, ASN_OCTET_STR, RWRITE, var_multicastConfig, 1, {3}},

#define IGMPSNOOPINGMEMBGROUPADDR		4
    {IGMPSNOOPINGMEMBGROUPADDR, ASN_IPADDRESS, RONLY, var_igmpSnoopingMembTable, 3, {4, 1, 1}},
#define IGMPSNOOPINGMEMBPORT		5
    {IGMPSNOOPINGMEMBPORT, ASN_INTEGER, RONLY, var_igmpSnoopingMembTable, 3, {4, 1, 2}},
#define IGMPSNOOPINGMEMBVID		6
    {IGMPSNOOPINGMEMBVID, ASN_INTEGER, RONLY, var_igmpSnoopingMembTable, 3,  {4, 1, 3}},
#define IGMPSNOOPINGMEMBEXPIRE		7
    {IGMPSNOOPINGMEMBEXPIRE, ASN_INTEGER, RONLY, var_igmpSnoopingMembTable, 3, {4, 1, 4}},
};

/*
 * (L = length of the oidsuffix)
 */


/** Initializes the multicastConfig module */
void
init_multicastConfig(void)
{

    DEBUGMSGTL(("multicastConfig", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("multicastConfig", multicastConfig_variables, variable4,
                 multicastConfig_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_multicastConfig():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_multicastConfig(struct variable *vp,
                    oid * name,
                    size_t *length,
                    int exact,
                    size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later
     */
    static long     long_ret;
    static unsigned char string[32];

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    // get current configuration
    epon_callback_context_t context;
    context.invoke_id = invoke_id++;
    context.apps_data = (void *)apps_data++;
    epon_request_onu_igmp_snooping_get(epon_onu_igmp_snooping_get_cb,
                                context, 0, 1);

    context.invoke_id = invoke_id++;
    context.apps_data = (void *)apps_data++;
    epon_request_onu_igmp_timer_get(epon_onu_igmp_timer_get_cb,
                        context, 0);

    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "SAL API returned, vp->magic=%d\n", vp->magic);

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IGMPSNOOPINGENABLE:
        *write_method = write_igmpSnoopingEnable;
        long_ret = igmp_config_old.enable;
        return (u_char *)&long_ret;

    case IGMPSNOOPINGAGETIME:
        *write_method = write_igmpSnoopingAgeTime;
        long_ret = igmp_timer_old;
        return (u_char *)&long_ret;

    case IGMPSNOOPINGFASTLEAVEENABLE:
        *write_method = write_igmpSnoopingFastleaveEnable;
        string[0] = (unsigned char)igmp_config_old.onu_fast_leave;
        *var_len = 1;
        return (u_char *)string;

    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in multicastConfig\n", vp->magic));
    }
    return NULL;
}


/*
 * var_igmpSnoopingMembTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_multicastConfig above.
 */
unsigned char  *
var_igmpSnoopingMembTable(struct variable *vp,
                          oid * name,
                          size_t *length,
                          int exact,
                          size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later
     */
    static long     long_ret,ip_addr;
    static unsigned char string[SPRINT_MAX_LEN];
    int port_idx;
	
    epon_onu_igmp_snooping_member_entry_t entry;
    epon_boolean_t next=0;
    epon_return_code_t sal_return;

  /*
     * object identifier is of form:
     *  1, 3, 6, 1, 4, 1, 1949, 1, 3, 10, 100, 16, 6, 1 ,4,1,?.A.B.C.D.PORT,  where A.B.C.D is IP address. PORT is port id
     * IPADDR starts at offset 17.
     */
    oid			    lowest[22];
    oid			    current[22], *op;
    u_char		    *cp;
    bool matched=FALSE;


    /* fill in object part of name for current (less sizeof instance part) */
    memcpy( (char *)current,(char *)vp->name, (int)vp->namelen * sizeof(oid));

   //get IP by SAL api

	entry.address=0;
	entry.port=0;
	//next=1;
	sal_return= epon_onu_igmp_snooping_member_read(&entry,  1);
	if(EPON_RETURN_SUCCESS!=sal_return){
		diag_printf("Error SAL epon_onu_igmp_snooping_member_read return %d\n",sal_return);
		return NULL;
		}
	//else
	//	diag_printf("entry addr 0x%x\t port 0x%x  \tvlan 0x%x \texpire 0x%x\n",entry.address,entry.port,entry.vlan,entry.expire);

	while(0xFFFFFFFF!=entry.address){	
	ip_addr = htonl(entry.address);
	cp = (u_char *)&ip_addr;
	op = current + 17;
	*op++ = *cp++;
	*op++ = *cp++;
	*op++ = *cp++;
	*op++ = *cp++;

	op=current + 21;
	*op = entry.port;
	
	if (exact){
	    if (snmp_oid_compare(current, 22, name, *length) == 0) {
		memcpy( (char *)lowest,(char *)current, 22 * sizeof(oid));
		matched= TRUE;
              break;	/* no need to search further */
	    }
	} else {
	    if ((snmp_oid_compare(current, 22, name, *length) > 0) &&
                (!matched || (snmp_oid_compare(current, 22, lowest, 22) < 0))) {
		/*
		 * if new one is greater than input and closer to input than
		 * previous lowest, save this one as the "next" one.
		 */
		memcpy( (char *)lowest,(char *)current, 22 * sizeof(oid));
		matched= TRUE;
	    }
	}
	epon_onu_igmp_snooping_member_read(&entry,  1);
	//diag_printf("entry addr is 0x%x\n",entry.address);
    }

    if ( ! matched )
        return NULL;

    memcpy( (char *)name,(char *)lowest, 22 * sizeof(oid));

    *length = 22;
    *write_method = 0;
    *var_len = sizeof(long_return);

    switch (vp->magic) {
    case IGMPSNOOPINGMEMBGROUPADDR:

	op = name + 17;
	cp = string;
	*cp++=*op++;
	*cp++=*op++;
	*cp++=*op++;
	*cp++=*op++;
	
        return (unsigned char *) string;


    case IGMPSNOOPINGMEMBPORT:
         long_ret=name[21];
        return (u_char *)&long_ret;

    case IGMPSNOOPINGMEMBVID:
       //get IP_ADDR
	op = name + 17;
	cp =(char *)&ip_addr;
	*cp++=*op++;
	*cp++=*op++;
	*cp++=*op++;
	*cp++=*op++;

	//diag_printf("ip_addr is 0x%x \n",ip_addr);
	ip_addr=htonl(ip_addr);
	//diag_printf("htonl ip_addr is 0x%x \n",ip_addr);
	//get port_idx
	port_idx=name[21];	

	entry.address = ip_addr;
	entry.port = port_idx;
	//diag_printf("before entry addr 0x%x\t port 0x%x  \tvlan 0x%x \texpire 0x%x\n",entry.address,entry.port,entry.vlan,entry.expire);
	epon_onu_igmp_snooping_member_read(&entry,  0);
	//diag_printf("after   entry addr 0x%x\t port 0x%x  \tvlan 0x%x \texpire 0x%x\n\n",entry.address,entry.port,entry.vlan,entry.expire);
	if(0xFFFFFFFF==entry.address)
		long_ret = 0xffffffff;	
	else
       	long_ret = entry.vlan;
	
        return (u_char *)&long_ret;

    case IGMPSNOOPINGMEMBEXPIRE:
       //get IP_ADDR
	op = name + 17;
	cp =(char *)&ip_addr;
	*cp++=*op++;
	*cp++=*op++;
	*cp++=*op++;
	*cp++=*op++;
		
	ip_addr=htonl(ip_addr);
	//get port_idx
	port_idx=name[21];

	entry.address = ip_addr;
	entry.port = port_idx;	
	//diag_printf("1 entry addr 0x%x\t port 0x%x  \tvlan 0x%x \texpire 0x%x\n",entry.address,entry.port,entry.vlan,entry.expire);
	epon_onu_igmp_snooping_member_read(&entry,  0);
	//diag_printf("2 entry addr 0x%x\t port 0x%x  \tvlan 0x%x \texpire 0x%x\n",entry.address,entry.port,entry.vlan,entry.expire);

	if(0xFFFFFFFF==entry.address)
		long_ret = 0xffffffff;	
	else
       	long_ret = entry.expire;
	
        long_ret = entry.expire;
        return (u_char *)&long_ret;

    default:
        ERROR_MSG("");
    }
    return NULL;
}



int
write_igmpSnoopingEnable(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    epon_callback_context_t context;

    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write_igmpSnoopingEnable called, action=%d\n", action);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write to multicastConfig not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write to multicastConfig: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        size = var_val_len;
        value = *(long *) var_val;
	 memset(&igmp_config, 0, sizeof(igmp_config));
        igmp_config.version = 1;
        igmp_config.enable = (epon_boolean_t)value;
        // here value will be an long int while enable is boolean, so memcpy not working
        // memcpy(&(igmp_config.enable), &value, size);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
	    igmp_config.enable = igmp_config_old.enable;
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write_igmpSnoopingEnable calling SAL\n");
        context.invoke_id = invoke_id++;
        context.apps_data = (void *)apps_data++;
        igmp_config.mask = 0x01;
        epon_request_onu_igmp_snooping_set(epon_onu_igmp_snooping_set_common_cb,
                                    context, 0, 1, &igmp_config);
        IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "new value of igmp_config.enable: %d\n", igmp_config.enable);
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_igmpSnoopingAgeTime(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    epon_callback_context_t context;

    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write_igmpSnoopingAgeTime called\n");

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write to multicastConfig not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write to multicastConfig: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        size = var_val_len;
        value = *(long *) var_val;
	    memcpy(&igmp_timer, &value, size);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
	    igmp_timer = igmp_timer_old;
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write_igmpSnoopingAgeTime calling SAL\n");
        context.invoke_id = invoke_id++;
        context.apps_data = (void *)apps_data++;
        epon_request_onu_igmp_timer_set(epon_onu_igmp_snooping_set_common_cb,
                                    context, 0, igmp_timer);
        IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "new value of igmp_timer: %d\n", igmp_timer);
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_igmpSnoopingFastleaveEnable(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    char            value;
    int             size;
    epon_callback_context_t context;

    IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write_igmpSnoopingFastleaveEnable called\n");

    switch (action) {
    case RESERVE1:      /* Check values for acceptability */
        if (var_val_type != ASN_OCTET_STR) {
            IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write to multicastConfig not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write to multicastConfig: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:      /* Allocate memory and similar resources */
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        size = var_val_len;
        value = *(char *) var_val;

		/* Save the old value, in case of UNDO */
	    // old value already got in igmp_config_old
	    //memcpy(&(igmp_config.onu_fast_leave), &value, size);
	    memset(&igmp_config, 0, sizeof(igmp_config));
           igmp_config.version=1;
           igmp_config.onu_fast_leave = value;           
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
	    igmp_config.onu_fast_leave = igmp_config_old.onu_fast_leave;
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "write_igmpSnoopingFastleaveEnable calling SAL\n");
        context.invoke_id = invoke_id++;
        context.apps_data = (void *)apps_data++;
        igmp_config.mask = 0x20;
        epon_request_onu_igmp_snooping_set(epon_onu_igmp_snooping_set_common_cb,
                                    context, 0, 1, &igmp_config);
        IROS_LOG_DBG3(IROS_MODULE_ID_SNMP, "new value of igmp_config.onu_fast_leave: 0x%x\n", igmp_config.onu_fast_leave);

        break;
    }
    return SNMP_ERR_NOERROR;
}
